"""
Supervisor Agent: Orchestrator & State Manager
Routes traffic, manages state, and formats final output.
"""
import logging
from typing import Any, Dict

from langchain_core.messages import AIMessage
from agents.base_agent import BaseAgent
from services.memory import persist_conversation_turn
from src.core.logger import configure_logging
from src.core.state import QueryResState

logger = configure_logging(logging.INFO)


class SupervisorAgent(BaseAgent):
    """
    Supervisor Agent: Project manager and orchestrator.
    - Routes messages through agent pipeline
    - Manages conversation state
    - Formats final response for user
    - Persists conversation to database
    """

    def __init__(self):
        super().__init__("Supervisor")

    def _finalize_response(self, state: Dict[str, Any], final_text: str) -> Dict[str, Any]:
        """Finalize response and update message history."""
        self._log_execution("FINALIZE", f"Response length: {len(final_text)} chars")

        # Append AI message to conversation
        updated_messages = state.get("messages", []) + [
            AIMessage(
                content=final_text,
                additional_kwargs={"turn_id": state.get("turn_id", 0)},
            )
        ]

        return {
            "final_response": final_text,
            "messages": updated_messages,
        }

    def execute(self, state: QueryResState) -> Dict[str, Any]:
        """Execute supervisor logic for routing and response formatting."""
        self._log_execution("INIT", "Starting supervision phase")

        # Check for critical failures
        if state.get("query_harmful") and state.get("auditor_fail"):
            final_text = (
                "I apologize, but your request appears to be outside my specialized "
                "financial knowledge base or violates my safety policies."
            )
            logger.warning("Query rejected due to safety violation")
            return self._finalize_response(state, final_text)

        if state.get("response_harmful") and state.get("auditor_fail"):
            final_text = (
                "I apologize, but there seems to be some error from our side. "
                "Please try again with a rephrased query."
            )
            logger.warning("Response rejected due to safety violation")
            return self._finalize_response(state, final_text)

        if state.get("parsed_query") and not state["parsed_query"].get("companies"):
            final_text = (
                "I am currently unable to locate the requested company in our knowledge base. "
                "Please ensure the company name or ticker is correct."
            )
            logger.info("Query needs company clarification")
            return self._finalize_response(state, final_text)

        if state.get("parsed_query") and not state["parsed_query"].get("years"):
            final_text = (
                "I couldn't identify a specific fiscal period. "
                "Please specify a year (e.g., 2023) or quarter (e.g., Q2)."
            )
            logger.info("Query needs period clarification")
            return self._finalize_response(state, final_text)

        if state.get("researcher_fail"):
            final_text = (
                "I encountered difficulty retrieving specific data points for this query. "
                "Please rephrase your request or provide more details."
            )
            logger.warning("Retrieval failed")
            return self._finalize_response(state, final_text)

        # Success path: aggregate outputs
        sec_out = state.get("llm_response_sec", "").strip()
        trans_out = state.get("llm_response_trans", "").strip()

        if sec_out or trans_out:
            logger.info("Aggregating successful analysis")
            sections = []

            if sec_out:
                sections.append(f"## SEC Filing Analysis\n\n{sec_out}")

            if trans_out:
                sections.append(f"## Management Commentary (Earnings Calls)\n\n{trans_out}")

            final_text = "\n\n---\n\n".join(sections)

            # Persist successful turn
            try:
                persist_conversation_turn(state)
                logger.info("Conversation turn persisted")
            except Exception as e:
                logger.warning(f"Failed to persist conversation: {str(e)}")

            return self._finalize_response(state, final_text)

        # No answer generated
        logger.warning("No answer generated by analyst")
        final_text = (
            "I was unable to generate a complete answer. "
            "Please try rephrasing your question."
        )
        return self._finalize_response(state, final_text)